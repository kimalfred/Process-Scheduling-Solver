<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CPU Scheduling TUtorial</title>
    <link rel="icon" type="image/png" href="/home page/logoa.png">
    <link rel="stylesheet" href="infostyle.css" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" />
  </head>
  <body>
    <nav class="sidebar">
      <a href="/home page/landingpage.html" class="logo">Home</a>

      <div class="menu-content">
        <ul class="menu-items">

          <li class="item">
            <a href="#">CPU Scheduling</a>
          </li>

          <li class="item">
            <a href="#FCFS">First Come First Serve</a>
          </li>

          <li class="item">
            <a href="#SJF">Shortest Job First</a>
          </li>

          <li class="item">
            <a href="#SRTF">Shortest Remaining Time First</a>
          </li>
          
          <li class="item">
            <a href="#PRIO">Priority (Preemptive)</a>
          </li>

          <li class="item">
            <a href="#NON-PRIO">Priority (Non-Preemptive)</a>
          </li>

          <li class="item">
            <a href="#RR">Round-Robin</a>
          </li>

          <li class="item">
            <div class="submenu-item">
              <span>Process Calculator</span>
              <i class="fa-solid fa-chevron-right"></i>
            </div>
            <ul class="menu-items submenu">
              <div class="menu-title">
                <i class="fa-solid fa-chevron-left"></i>
                Tutorial
              </div>
              <li class="item">
                <a href="/fcfs algo/fcfs.html">First Come First Serve</a>
              </li>

              <li class="item">
                <a href="/sjf algo/sjf.html">Shortest-Job-First</a>
              </li>

              <li class="item">
                <a href="/srtf algo/srtf.html">Shortest-Remaining-Time-First</a>
              </li>

              <li class="item">
                <a href="/Prio p algo/Prio p.html">Priority (Preemptive)</a>
              </li>

              <li class="item">
                <a href="/Prio np algo/Prio np.html">Priority (Non-Preemptive)</a>
              </li>

              <li class="item">
                <a href="/rr algo/rr.html">Round Robin</a>
              </li>
            </ul>
          </li>

        </ul>
      </div>
    </nav>

    <nav class="navbar">
      <i class="fa-solid fa-bars" id="sidebar-close"></i>
    </nav>
    <main class="main">
      <div class="container">
        <div class="wrapper">
          <img class ="cpu" src="CPU-Scheduling.jpg" alt="cpu">
          <div class="cpu-text">
          <h1>What is <br>  CPU-Scheduling?</h1>
          <p>
            CPU scheduling, a critical component of process management, facilitates the efficient utilization of the CPU by allowing processes to execute while others are temporarily delayed due to resource unavailability such as I/O operations. Its primary objective is to ensure timely completion of tasks, enhancing system efficiency, speed, and fairness. When the CPU is idle, the operating system employs a temporary scheduler to select the next process from the queue of ready processes awaiting execution. This scheduler evaluates the readiness of each process in memory and allocates the CPU to the most suitable candidate, thereby optimizing resource utilization and overall system performance.
          </p>
          </div>
        </div>
      </div>
    </main>

    <style>
      h2 {
        color: rgb(252, 0, 0);
      }
    </style>

    <section class="container py-5" id="FCFS">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>First Come First Serve</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
            <h5>So let's work on some examples from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>The first would be to solve for the completion time, and this can be done by using a gantt chart. With both the arrival time and the given time, we could use that for the gantt chart.</li>
              <li>So using the arrival time of the processes, we have to process the one who came earlier, so it's going to be <b>J1</b> as it's the one who came first with the arrival time of 0.</li>
              <li>Then we have to process the <b>J1</b> with its burst time of 8.</li>
              <li>After we processed the first job, as you can see, we ended it at 8. Within those 8 came 2 jobs, which were <b>J3</b> and <b>J5</b>, which have a burst time of 7 and 4, respectively.</li>
              <li>To know which one to process first in a queue of jobs in the <b> First Come First Serve Algorithm </b> we have to use the arrival time of the queued jobs.</li>
              <li>In this case we would process the <b>J5</b> first because it arrived much earlier than the <b>J3</b>.</li>
              <li>Then we would use all of the burst time of <b>J5</b>, and the process ended at 9, then another job arrived, which is the j4.</li>
              <li>Using the same criteria we used earlier for multiple queued jobs, we would process the one who arrived first, which in this case is <b>J3</b>, which ended at 16. Inside those 16 then arrived another job, which is <b>J2</b>.</li>
              <li>Then we'll use the criteria again, which in this case is <b>J4</b> because it arrived first than <b>j2</b>. After we processed <b>J4</b>, which ended at 21, no other job arrived, so we will process the remaining job, <b>J2</b>, which ended at 30.</li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 16 = 9), J4 = ( 9 - 21 = 12), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (9 - 7 = 2), j4 = (12 - 5 = 7), j5 = (5 - 1 =4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="FCFS-AVG.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 54 divided by 5, which gives us 10.8</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 24 divided by 5, which gives us 4.8 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="SJF">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>Shortest Job First</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The Shortest Job First (SJF) or Shortest Job Next (SJN) is a scheduling policy that prioritizes the process with the smallest execution time. This can be either preemptive or non-preemptive. Itâ€™s a Greedy Algorithm known for its minimal average waiting time among all scheduling algorithms. However, it may lead to starvation if shorter processes continually arrive, which can be mitigated using the concept of ageing. While itâ€™s practically challenging to implement as the Operating System may not know burst times, several methods, like a weighted average of previous execution times, can estimate a jobâ€™s execution time. This makes SJF suitable for specialized environments where accurate running time estimates are available. The algorithm works by sorting all processes according to their arrival time, then selecting the process with the minimum arrival and burst time. After a process is completed, a pool of processes that arrive afterward is created, and the process with the minimum burst time is selected from this pool. </h5>
            <img class = fcfspic src="shortest job first.png" alt="fcfspic">
            <h5>So let's work on some examples for Shortest Job First from the given picture above and break it down bit by bit.</h5>
            <ul class="steps">
              <h2>Gantt Chart</h2>
              <li>As we did in the first come, first serve algorithm, we would <b>create a Gantt chart based on the arrival and burst time of our jobs.</b></li>
              <li>Although it's almost the same, it has a different way of doing its priority compared to the <b>first come, first serve</b>.</li>
              <li><b>Shortest Job First uses burst time</b> to know which to process next if there are multiple jobs on the ram.</li>
              <li>So with that in mind we can now create a gantt chart for our <b>Shortest Jobs First Algorithm</b>.</li>
              <li>Back to the table, we can see that <b>J1 arrived first</b> and no other jobs are in the ram, so now we have to process j1 all the way.</li>
              <li>Now that we have a <b>burst time of 8, J3 and J5 arrived.</b></li>
              <li>And now we can use the criteria for <b>Shortest Job First</b>, which is that <b>when there are more than 1 process inside the ram</b>, the one who will be <b>processed first is the one with the lowest burst time.</b></li>
              <li>In this case, based on the table above, <b>J5 has a lower burst time than J3, so J5 will be processed first.</b> After we processed that we were at 9 m/s,  another job arrived, which is the <b>J4</b>.</li>
              <li>So by utilizing the criteria again, <b>we will process J4 first as it has a lower burst time than J3 in the queue</b> ending at 14 then comes <b>J2. Now we will process J3 as it has a lower burst time than j2</b>ending at 21, and lastly, we will now process <b>J2 and end at 30 m/s.</b></j2></li>
              <h2>Turnaround Time and Waiting Time</h2>
              <h4>Turnaround-Time</h4>
              <li>Now that our Gantt chart is done, we can now solve the remaining parts of the table, which are the <b>turnaround time and waiting time.</b></li>
              <li>First would be the <b>turnaround time</b>, which we can solve by subtracting the <b>completion time</b> of the job from its <b>arrival time</b>.</li>
              <li>Now that we know the equation for the turnaround time, we can now calculate the turnaround time for each job.</li>
              <li>So we have <b>J1</b>, which has an <b>arrival time of 0</b> and a <b>completion time of 8</b>. Using the formula for the <b>turnaround-time (0-8)</b>, the answer would be 8. Now do the same for the others. <b>J2 = (10 - 30 = 20), J3 = (7 - 21 = 14), J4 = ( 9 - 14 = 5), J5 = (4 - 9 = 5)</b>.</li>
              <li>Now that we got the <b>turnaround-time</b> of all of the jobs we can now calculate the waiting time of each job. This is done by subtracting the <b>turnaround-time and the burst time</b> of each jobs</li>
              <h4>Waiting Time</h4>
              <li>With that, let's calculate the <b>waiting time</b> for each job.</li>
              <li>For <b>J1</b>, we can see that it has a <b>turnaround time of 8 and a burst time of 8</b>. By subtracting those two, we get a 0 as an answer.Now lets do the rest of the jobs.</li>
              <li>For <b>J2</b>,it has a <b>turnaround time of 20</b> and a <b>burst time of 9 </b>so <b>J2 = (20 - 9 = 11)</b><b>J3 = (14 - 7 = 7), j4 = (5 - 5 = 0), j5 = (5 - 1 = 4)</b></li>
              <h2>Average turnaround time, average waiting time, CPU Utilization</h2>
              <img class="fcfsavg" src="sjf avg.png" alt="fcfsavg">
              <h4>Average turnaround time</h4>
              <li>The calculations for the <b>Average turnaround time</b> are as follows: get the summation of <b>turnaround time</b> and divide the sum by how many items are there. In this case, the summation of <b>turnaround time is 52 divided by 5, which gives us 10.4</b>.</li>
              <li>Next is the <b>average waiting time</b>. It's just as simple: we're going to do the same thing as we did for the average turnaround time. so it will be the summation of <b>Waiting time 22 divided by 5, which gives us 4.4 as the answer</b></li>
              <li>Now for the CPU utilization. In this one, we are going to need the sum of our burst time, divide it by our total completion time, and multiply it by 100. So in this case, the <b>summation of burst time is 30; divide it by our end time, which is 30; then multiply by 100</b>, we get a total of <b>100% CPU-Utilization</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="SRTF">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>First Come First Serve</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="PRIO">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>First Come First Serve</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="NON-PRIO">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>First Come First Serve</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
          </div>
        </div>
      </div>
    </section>

    <section class="container py-5" id="RR">
      <div class="row mt-4 py-3">
        <div class="col-12 d-flex flex-column text-right justify-content-right" id="paragraph">
          <h2>First Come First Serve</h2>  
          <h5 class="text-secondary fw-normal py-2 Lucida Console">The simplest CPU scheduling algorithm, FCFS (First Come, First Serve), prioritizes processes based on their arrival times, utilizing a FIFO queue. As processes enter the ready queue, their PCBs are appended to the queue's tail. When the CPU becomes available, the process at the head of the queue is allocated the CPU and subsequently removed from the queue. FCFS can be either preemptive or non-preemptive, executing tasks in the order they arrive. While easy to implement, FCFS may result in high wait times and is less efficient, making it better suited for batch systems where longer process durations are tolerable.</h5>
            <img class = fcfspic src="FCFS-PIC.png" alt="fcfspic">
          </div>
        </div>
      </div>
    </section>
    

    <script src="info.js"></script>
     <!-- Footer -->
     
     <!-- Bootstrap script link -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
  </body>
</html>